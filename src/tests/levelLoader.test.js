/**\n * Jest unit tests for the Level loader (src/level.js).\n *\n * These tests mock `fetch` and the Asset Loader to run without a network\n * or real Pixi resources.\n */\n\n// Mock logger to suppress console noise and allow verification.\njest.mock('../logger', () => ({\n  info: jest.fn(),\n  warn: jest.fn(),\n  error: jest.fn(),\n  debug: jest.fn(),\n}));\n\n// Mock assetLoader â€“ return a dummy texture.\njest.mock('../assetLoader', () => ({\n  getTilesetTexture: jest.fn(() => ({\n    // Minimal texture stub that Pixi can accept.\n    baseTexture: { width: 256, height: 256 },\n    width: 32,\n    height: 32,\n  })),\n}));\n\n// Import modules **after** the mocks so they receive the mocked versions.\nconst Level = require('../level');\nconst logger = require('../logger');\nconst { getTilesetTexture } = require('../assetLoader');\nconst { TILE_SIZE } = require('../constants');\n\n// Mock fetch globally.\nglobal.fetch = jest.fn();\n\n// Helper to create a valid level JSON object.\nfunction createValidLevel() {\n  return {\n    width: 4,\n    height: 3,\n    tiles: [\n      [0, 1, 0, 2],\n      [0, 0, 2, 2],\n      [1, 1, 0, 0],\n    ],\n    collision: [1, 2],\n    goal: { x: 3, y: 2 },\n  };\n}\n\ndescribe('Level.loadLevel', () => {\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  test('loads a valid level and constructs the collision grid', async () => {\n    const levelJson = createValidLevel();\n    fetch.mockResolvedValueOnce({\n      ok: true,\n      json: async () => levelJson,\n    });\n\n    const level = await Level.loadLevel('http://example.com/level.json');\n\n    // Verify basic properties.\n    expect(level.width).toBe(levelJson.width);\n    expect(level.height).toBe(levelJson.height);\n    expect(level.collisionGrid.length).toBe(levelJson.height);\n    expect(level.collisionGrid[0].length).toBe(levelJson.width);\n\n    // Check that solid tiles match the collision array.\n    expect(level.isSolid(1, 0)).toBe(true); // tile ID 1\n    expect(level.isSolid(3, 0)).toBe(true); // tile ID 2\n    expect(level.isSolid(0, 0)).toBe(false); // tile ID 0\n    expect(level.getGoalPosition()).toEqual({ x: 3, y: 2 });\n  });\n\n  test('rejects when fetch fails', async () => {\n    fetch.mockResolvedValueOnce({ ok: false, status: 404 });\n    await expect(Level.loadLevel('bad/url')).rejects.toThrow('Network response was not ok');\n    expect(logger.error).toHaveBeenCalled();\n  });\n\n  test('rejects when JSON is malformed', async () => {\n    fetch.mockResolvedValueOnce({\n      ok: true,\n      json: async () => 'this is not an object',\n    });\n    await expect(Level.loadLevel('url')).rejects.toThrow();\n    expect(logger.error).toHaveBeenCalled();\n  });\n\n  test('rejects when JSON fails schema validation (missing tiles)', async () => {\n    const broken = { ...createValidLevel() };\n    delete broken.tiles;\n    fetch.mockResolvedValueOnce({\n      ok: true,\n      json: async () => broken,\n    });\n    await expect(Level.loadLevel('url')).rejects.toThrow('Invalid level JSON');\n    expect(logger.error).toHaveBeenCalled();\n  });\n});
